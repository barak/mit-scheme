Floating-point exceptions are now _not_ trapped by default.

This follows IEEE 754's semantics for the default mode, and it has been
the case on some platforms (e.g, macOS) for some time.

If you want to trap on (e.g.) invalid-operation, you can do

(flo:with-exceptions-trapped (flo:exception:invalid-operation)
  (lambda ()
    ...))

(flo:trappable-exceptions) gives the set of all exceptions that can be
trapped.  Human-readable names are available by (flo:exceptions->names
(flo:trappable-exceptions)).

You can also test for floating-point exceptions after a computation
without trapping.  Before you can do this for the first time in any
thread, you must clear the floating-point exceptions (otherwise there
may be residual garbage from past computations):

(flo:preserving-environment
 (lambda ()
   (flo:clear-exceptions! (flo:supported-exceptions))
   (let ((x (do-big-computation)))
     (if (not (zero? (flo:test-exceptions (flo:exception:underflow))))
         (warn "underflow"))
     x)))
