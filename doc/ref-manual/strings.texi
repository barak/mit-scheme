@node Strings, Lists, Characters, Top
@chapter Strings

@menu
* Searching Strings::
* Matching Strings::
* Regular Expressions::
@end menu

@cindex string, character (defn)
@cindex external representation, for string
@cindex " as external representation
@cindex double quote, as external representation
@cindex \ as escape character in string
@cindex backslash, as escape character in string
@cindex escape character, for string
@findex "
Strings are sequences of characters.  Strings are written as sequences
of characters enclosed within quotation marks (@code{"}).  Within a
string literal, various escape sequences represent characters other
than themselves.  Escape sequences always start with a backslash
(@code{\}):

@display
@group
@code{\a} : alarm, U+0007
@code{\b} : backspace, U+0008
@code{\t} : character tabulation, U+0009
@code{\n} : linefeed, U+000A
@code{\r} : return, U+000D
@code{\"} : double quote, U+0022
@code{\\} : backslash, U+005C
@code{\|} : vertical line, U+007C
@code{\}@var{intraline-whitespace}* @var{line-ending} @var{intraline-whitespace}*
     : nothing
@code{\x}@var{hex-scalar-value}@code{;}
     : specified character (note the terminating semi-colon).
@end group
@end display
@findex \a
@findex \b
@findex \t
@findex \n
@findex \r
@findex \"
@findex \\
@findex \|
@findex \x

The result is unspecified if any other character in a string occurs
after a backslash.

Except for a line ending, any character outside of an escape sequence
stands for itself in the string literal.  A line ending which is
preceded by @code{\}@var{intraline-whitespace} expands to nothing
(along with any trailing intraline whitespace), and can be used to
indent strings for improved legibility. Any other line ending has the
same effect as inserting a @code{\n} character into the string.

Examples:

@example
@group
"The word \"recursion\" has many meanings."
"Another example:\ntwo lines of text"
"Here's text \
   containing just one line"
"\x03B1; is named GREEK SMALL LETTER ALPHA."
@end group
@end example

@cindex length, of string (defn)
@cindex index, of string (defn)
@cindex valid index, of string (defn)
@cindex string length (defn)
@cindex string index (defn)
The @emph{length} of a string is the number of characters that it
contains.  This number is an exact, non-negative integer that is fixed
when the string is created.  The @dfn{valid indexes} of a string are
the exact non-negative integers less than the length of the string.
The first character of a string has index 0, the second has index 1,
and so on.

@cindex case sensitivity, of string operations
@cindex -ci, in string procedure name
Some of the procedures that operate on strings ignore the difference
between upper and lower case.  The names of the versions that ignore
case end with @samp{-ci} (for ``case insensitive'').

Implementations may forbid certain characters from appearing in
strings.  However, with the exception of @code{#\null}, ASCII
characters must not be forbidden.  For example, an implementation
might support the entire Unicode repertoire, but only allow characters
U+0001 to U+00FF (the Latin-1 repertoire without @code{#\null}) in
strings.

Implementation note: MIT/GNU Scheme allows any ``bitless'' character
to be stored in a string.  In effect this means any character with a
Unicode code point, including surrogates.

It is an error to pass such a forbidden character to
@code{make-string}, @code{string}, @code{string-set!}, or
@code{string-fill!}, as part of the list passed to
@code{list->string}, or as part of the vector passed to
@code{vector->string}, or in UTF-8 encoded form within a bytevector
passed to @code{utf8->string}.  It is also an error for a procedure
passed to @code{string-map} to return a forbidden character, or for
@code{read-string} to attempt to read one.

@deffn {standard procedure} string? obj
Returns @code{#t} if @var{obj} is a string, otherwise returns @code{#f}.
@end deffn

@deffn {standard procedure} make-string k [char]
The @code{make-string} procedure returns a newly allocated string of
length @var{k}.  If @var{char} is given, then all the characters of the string
are initialized to @var{char}, otherwise the contents of the
string are unspecified.
@end deffn

@deffn {standard procedure} string char @dots{}
Returns a newly allocated string composed of the arguments.  It is
analogous to @code{list}.
@end deffn

@deffn {standard procedure} string-length string
Returns the number of characters in the given @var{string}.
@end deffn

@deffn {standard procedure} string-ref string k
It is an error if @var{k} is not a valid index of @var{string}.

The @code{string-ref} procedure returns character @var{k} of
@var{string} using zero-origin indexing.  There is no requirement for
this procedure to execute in constant time.
@end deffn

@deffn {standard procedure} string-set! string k char
It is an error if @var{k} is not a valid index of @var{string}.

The @code{string-set!} procedure stores @var{char} in element @var{k} of @var{string}.
There is no requirement for this procedure to execute in constant time.

@example
@group
(define (f) (make-string 3 #\*))
(define (g) "***")
(string-set! (f) 0 #\?)  @result{}  @r{@i{unspecified}}
(string-set! (g) 0 #\?)  @result{}  @r{@i{error}}
(string-set! (symbol->string 'immutable) 0 #\?)  @result{}  @r{@i{error}}
@end group
@end example
@end deffn

@deffn {standard procedure} string=? string1 string2 string @dots{}
Returns @code{#t} if all the strings are the same length and contain
exactly the same characters in the same positions, otherwise returns
@code{#f}.
@end deffn

@deffn {standard procedure} string-ci=? string1 string2 string @dots{}
Returns @code{#t} if, after case-folding, all the strings are the same
length and contain the same characters in the same positions,
otherwise returns @code{#f}.  Specifically, these procedures behave as
if @code{string-foldcase} were applied to their arguments before
comparing them.
@end deffn

@deffn {standard procedure} string<? string1 string2 string @dots{}
@deffnx {standard procedure} string-ci<? string1 string2 string @dots{}
@deffnx {standard procedure} string>? string1 string2 string @dots{}
@deffnx {standard procedure} string-ci>? string1 string2 string @dots{}
@deffnx {standard procedure} string<=? string1 string2 string @dots{}
@deffnx {standard procedure} string-ci<=? string1 string2 string @dots{}
@deffnx {standard procedure} string>=? string1 string2 string @dots{}
@deffnx {standard procedure} string-ci>=? string1 string2 string @dots{}
These procedures return @code{#t} if their arguments are (respectively):
monotonically increasing, monotonically decreasing,
monotonically non-decreasing, or monotonically non-increasing.

These predicates are required to be transitive.

These procedures compare strings in an implementation-defined way.
One approach is to make them the lexicographic extensions to strings
of the corresponding orderings on characters.  In that case,
@code{string<?}  would be the lexicographic ordering on strings
induced by the ordering @code{char<?} on characters, and if the two
strings differ in length but are the same up to the length of the
shorter string, the shorter string would be considered to be
lexicographically less than the longer string.  However, it is also
permitted to use the natural ordering imposed by the implementation's
internal representation of strings, or a more complex locale-specific
ordering.

In all cases, a pair of strings must satisfy exactly one of
@code{string<?}, @code{string=?}, and @code{string>?}, and must satisfy
@code{string<=?} if and only if they do not satisfy @code{string>?} and
@code{string>=?} if and only if they do not satisfy @code{string<?}.

The @samp{-ci} procedures behave as if they applied
@code{string-foldcase} to their arguments before invoking the
corresponding procedures without @samp{-ci}.
@end deffn

@deffn procedure string-compare string1 string2 if-eq if-lt if-gt
@deffnx procedure string-compare-ci string1 string2 if-eq if-lt if-gt
@var{If-eq}, @var{if-lt}, and @var{if-gt} are procedures of no arguments
(thunks).  The two strings are compared; if they are equal, @var{if-eq}
is applied, if @var{string1} is less than @var{string2}, @var{if-lt} is
applied, else if @var{string1} is greater than @var{string2},
@var{if-gt} is applied.  The value of the procedure is the value of the
thunk that is applied.

@code{string-compare} distinguishes uppercase and lowercase letters;@*
@code{string-compare-ci} does not.

@example
@group
(define (cheer) (display "Hooray!"))
(define (boo)   (display "Boo-hiss!"))
(string-compare "a" "b"  cheer  (lambda() 'ignore)  boo)
        @print{}  Hooray!
        @result{}  @r{unspecified}
@end group
@end example
@end deffn

@deffn {standard procedure} string-upcase string
@deffnx {standard procedure} string-downcase string
@deffnx {standard procedure} string-foldcase string
These procedures apply the Unicode full string uppercasing,
lowercasing, and case-folding algorithms to their arguments and return
the result.  In certain cases, the result differs in length from the
argument.  If the result is equal to the argument in the sense of
@code{string=?}, the argument may be returned.  Note that
language-sensitive mappings and foldings are not used.

The Unicode Standard prescribes special treatment of the Greek letter
@math{\Sigma}, whose normal lower-case form is @math{\sigma} but which
becomes @math{\varsigma} at the end of a word.  See
@uref{http://www.unicode.org/reports/tr44/, UAX #44} (part of the
Unicode Standard) for details.  However, implementations of @code
{string-downcase} are not required to provide this behavior, and may
choose to change @math{\Sigma} to @math{\sigma} in all cases.
@end deffn

@deffn procedure string-upper-case? string
@deffnx procedure string-lower-case? string
These procedures return @code{#t} if all the letters in the string are
lower case or upper case, otherwise they return @code{#f}.  The string
must contain at least one letter or the procedures return @code{#f}.

@example
@group
(map string-upper-case? '(""    "A"    "art"  "Art"  "ART"))
                       @result{} (#f    #t     #f     #f     #t)
@end group
@end example
@end deffn

@deffn {standard procedure} substring string start end
The @code{substring} procedure returns a newly allocated string formed
from the characters of @var{string} beginning with index @var{start}
and ending with index @var{end}.

This is equivalent to calling @code{string-copy} with the same
arguments, but is provided for backward compatibility and stylistic
flexibility.
@end deffn

@deffn {standard procedure} string-append string @dots{}
@deffnx procedure string-append* strings
Returns a newly allocated string whose characters are the
concatenation of the characters in the given strings.

The non-standard procedure @code{string-append*} is identical to
@code{string-append} but takes a single argument that's a list of
strings, rather than multiple string arguments.
@end deffn

@deffn {standard procedure} string->list string [start [end]]
@deffnx {standard procedure} list->string list
It is an error if any element of @var{list} is not a character.

The @code{string->list} procedure returns a newly allocated list of
the characters of @var{string} between @var{start} and @var{end}.
@code{list->string} returns a newly allocated string formed from the
elements in the list @var{list}.  In both procedures, order is
preserved.  @code{string->list} and @code{list->string} are inverses
so far as @code{equal?} is concerned.
@end deffn

@deffn {standard procedure} string-copy string [start [end]]
Returns a newly allocated copy of the part of the given @var{string}
between @var{start} and @var{end}.
@end deffn

@deffn {standard procedure} string-copy! to at from [start [end]]
It is an error if @var{at} is less than zero or greater than the
length of @var{to}.  It is also an error if @code{(- (string-length
@var{to}) @var{at})} is less than @code{(- @var{end} @var{start})}.

Copies the characters of string @var{from} between @var{start} and
@var{end} to string @var{to}, starting at @var{at}.  The order in
which characters are copied is unspecified, except that if the source
and destination overlap, copying takes place as if the source is first
copied into a temporary string and then into the destination.  This
can be achieved without allocating storage by making sure to copy in
the correct direction in such circumstances.

@example
@group
(define a "12345")
(define b (string-copy "abcde"))
(string-copy! b 1 a 0 2)
b @result{} "a12de"%
@end group
@end example
@end deffn

@deffn {standard procedure} string-fill! string fill [start [end]]
It is an error if @var{fill} is not a character.

The @code{string-fill!} procedure stores @var{fill} in the elements of
@var{string} between @var{start} and @var{end}.
@end deffn

@deffn procedure string-slice string [start [end]]
@cindex slice, of string
@cindex string slice
Returns a @dfn{slice} of @var{string}, restricted to the range of
characters specified by @var{start} and @var{end}.

A slice is a kind of string that provides a view into another string.
The slice behaves like any other string, but changes to a slice are
reflected in the original string and vice versa.

@example
@group
(define foo (string #\a #\b #\c #\d #\e))
foo @result{} "abcde"

(define bar (string-slice foo 1 4))
bar @result{} "bcd"

(string-set! foo 2 #\z)
foo @result{} "abzde"
bar @result{} "bzd"

(string-set! bar 1 #\y)
bar @result{} "byd"
foo @result{} "abyde"
@end group
@end example
@end deffn

@ignore

@deffn string object @dots{}
@deffn string* objects
@deffn string->vector string [start [end]]
@deffn vector->string vector [start [end]]

@deffn string-joiner [keyword object] @dots{}
@deffn string-joiner* [keyword object] @dots{}
@deffn string-splitter [keyword object] @dots{}
@deffn string-trimmer [keyword object] @dots{}
@deffn string-padder [keyword object] @dots{}

@deffn string-any proc string1 string @dots{}
@deffn string-count proc string1 string @dots{}
@deffn string-every proc string1 string @dots{}
@deffn string-find-first-index proc string1 string @dots{}
@deffn string-find-last-index proc string1 string @dots{}
@deffn string-for-each proc string1 string @dots{}
@deffn string-map proc string1 string @dots{}

@end ignore

@deffn procedure string-null? string
@cindex empty string, predicate for
@cindex null string, predicate for
Returns @code{#t} if @var{string} has zero length; otherwise returns
@code{#f}.

@example
@group
(string-null? "")               @result{}  #t
(string-null? "Hi")             @result{}  #f
@end group
@end example
@end deffn

@deffn procedure string-hash string [modulus]
@deffnx procedure string-hash-ci string [modulus]
@cindex hashing, of string
@findex string=?
@findex string-ci=?
@findex =
These procedures return an exact non-negative integer that can be used
for storing the specified @var{string} in a hash table.  Equal strings
(in the sense of @code{string=?} and @code{string-ci=?} respectively)
return equal (@code{=}) hash codes, and non-equal but similar strings
are usually mapped to distinct hash codes.

If the optional argument @var{modulus} is specified, it must be an
exact positive integer, and the result of the hash computation is
restricted to be less than that value.  This is equivalent to calling
@code{modulo} on the result, but may be faster.
@end deffn

@deffn procedure string-head string end
Equivalent to @code{(string-copy @var{string} 0 @var{end})}.
@end deffn

@deffn procedure string-tail string start
Equivalent to @code{(string-copy @var{string} @var{start})}.
@end deffn

@deffn procedure string-pad-left string k [char]
@deffnx procedure string-pad-right string k [char]
@cindex padding, of string
@findex #\space
These procedures return a newly allocated string created by padding
@var{string} out to length @var{k}, using @var{char}.  If @var{char} is
not given, it defaults to @code{#\space}.  If @var{k} is less than the
length of @var{string}, the resulting string is a truncated form of
@var{string}.  @code{string-pad-left} adds padding characters or
truncates from the beginning of the string (lowest indices), while
@code{string-pad-right} does so at the end of the string (highest
indices).

@example
@group
(string-pad-left "hello" 4)             @result{}  "ello"
(string-pad-left "hello" 8)             @result{}  "   hello"
(string-pad-left "hello" 8 #\*)         @result{}  "***hello"
(string-pad-right "hello" 4)            @result{}  "hell"
(string-pad-right "hello" 8)            @result{}  "hello   "
@end group
@end example
@end deffn

@deffn procedure string-trim string [char-set]
@deffnx procedure string-trim-left string [char-set]
@deffnx procedure string-trim-right string [char-set]
@cindex trimming, of string
@findex char-set:whitespace
Returns a newly allocated string created by removing all characters that
are not in @var{char-set} from: (@code{string-trim}) both ends of
@var{string}; (@code{string-trim-left}) the beginning of @var{string};
or (@code{string-trim-right}) the end of @var{string}.  @var{Char-set}
defaults to @code{char-set:not-whitespace}.

@example
@group
(string-trim "  in the end  ")          @result{}  "in the end"
(string-trim "              ")          @result{}  ""
(string-trim "100th" char-set:numeric)  @result{}  "100"
(string-trim-left "-.-+-=-" (char-set #\+))
                                        @result{}  "+-=-"
(string-trim "but (+ x y) is" (char-set #\( #\)))
                                        @result{}  "(+ x y)"
@end group
@end example
@end deffn

@deffn procedure string-replace string char1 char2
Returns a newly allocated string containing the same characters as
@var{string} except that all instances of @var{char1} have been
replaced by @var{char2}.
@end deffn

@node Searching Strings, Matching Strings, Strings, Strings
@section Searching Strings
@cindex searching, of string
@cindex character, searching string for
@cindex substring, searching string for

The first few procedures in this section perform @dfn{string search}, in
which a given string (the @dfn{text}) is searched to see if it contains
another given string (the @dfn{pattern}) as a proper substring.  At
present these procedures are implemented using a hybrid strategy.  For
short patterns of less than 4 characters, the naive string-search
algorithm is used.  For longer patterns, the Boyer-Moore string-search
algorithm is used.

@deffn procedure string-search-forward pattern string [start [end]]
@var{Pattern} must be a string.  Searches @var{string} for the leftmost
occurrence of the substring @var{pattern}.  If successful, the index of
the first character of the matched substring is returned; otherwise,
@code{#f} is returned.

@example
@group
(string-search-forward "rat" "pirate")
    @result{} 2
(string-search-forward "rat" "pirate rating")
    @result{} 2
(string-search-forward "rat" "pirate rating" 4 13)
    @result{} 7
(string-search-forward "rat" "pirate rating" 9 13)
    @result{} #f
@end group
@end example
@end deffn

@deffn procedure string-search-backward pattern string [start [end]]
@var{Pattern} must be a string.  Searches @var{string} for the rightmost
occurrence of the substring @var{pattern}.  If successful, the index to
the right of the last character of the matched substring is returned;
otherwise, @code{#f} is returned.

@example
@group
(string-search-backward "rat" "pirate")
    @result{} 5
(string-search-backward "rat" "pirate rating")
    @result{} 10
(string-search-backward "rat" "pirate rating" 1 8)
    @result{} 5
(string-search-backward "rat" "pirate rating" 9 13)
    @result{} #f
@end group
@end example
@end deffn

@deffn procedure string-search-all pattern string [start [end]]
@var{Pattern} must be a string.  Searches @var{string} to find all
occurrences of the substring @var{pattern}.  Returns a list of the
occurrences; each element of the list is an index pointing to the first
character of an occurrence.

@example
@group
(string-search-all "rat" "pirate")
    @result{} (2)
(string-search-all "rat" "pirate rating")
    @result{} (2 7)
(string-search-all "rat" "pirate rating" 4 13)
    @result{} (7)
(string-search-all "rat" "pirate rating" 9 13)
    @result{} ()
@end group
@end example
@end deffn

@deffn procedure substring? pattern string
@var{Pattern} must be a string.  Searches @var{string} to see if it
contains the substring @var{pattern}.  Returns @code{#t} if
@var{pattern} is a substring of @var{string}, otherwise returns
@code{#f}.

@example
@group
(substring? "rat" "pirate")             @result{}  #t
(substring? "rat" "outrage")            @result{}  #f
(substring? "" any-string)              @result{}  #t
(if (substring? "moon" text)
    (process-lunar text)
    'no-moon)
@end group
@end example
@end deffn

@deffn procedure string-find-next-char string char
@deffnx procedure substring-find-next-char string start end char
@deffnx procedure string-find-next-char-ci string char
@deffnx procedure substring-find-next-char-ci string start end char
Returns the index of the first occurrence of @var{char} in the string
(substring); returns @code{#f} if @var{char} does not appear in the
string.  For the substring procedures, the index returned is relative to
the entire string, not just the substring.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.

@example
@group
(string-find-next-char "Adam" #\A)              @result{}  0 
(substring-find-next-char "Adam" 1 4 #\A)       @result{}  #f
(substring-find-next-char-ci "Adam" 1 4 #\A)    @result{}  2 
@end group
@end example
@end deffn

@deffn procedure string-find-next-char-in-set string char-set
@deffnx procedure substring-find-next-char-in-set string start end char-set
Returns the index of the first character in the string (or substring)
that is also in @var{char-set}, or returns @code{#f} if none of the
characters in @var{char-set} occur in @var{string}.
For the substring procedure, only the substring is searched, but the
index returned is relative to the entire string, not just the substring.

@example
@group
(string-find-next-char-in-set my-string char-set:alphabetic)
    @result{}  @r{start position of the first word in} my-string
@r{; Can be used as a predicate:}
(if (string-find-next-char-in-set my-string
                                  (char-set #\( #\) ))
    'contains-parentheses
    'no-parentheses)
@end group
@end example
@end deffn

@deffn procedure string-find-previous-char string char
@deffnx procedure substring-find-previous-char string start end char
@deffnx procedure string-find-previous-char-ci string char
@deffnx procedure substring-find-previous-char-ci string start end char
Returns the index of the last occurrence of @var{char} in the string
(substring); returns @code{#f} if @var{char} doesn't appear in the
string.  For the substring procedures, the index returned is relative to
the entire string, not just the substring.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.
@end deffn

@deffn procedure string-find-previous-char-in-set string char-set
@deffnx procedure substring-find-previous-char-in-set string start end char-set
Returns the index of the last character in the string (substring) that
is also in @var{char-set}.  For the substring procedure, the index
returned is relative to the entire string, not just the substring.
@end deffn

@node Matching Strings, Regular Expressions, Searching Strings, Strings
@section Matching Strings
@cindex matching, of strings

@deffn procedure string-match-forward string1 string2
@deffnx procedure string-match-forward-ci string1 string2
Compares the two strings, starting from the beginning, and returns the
number of characters that are the same.  If the two strings start
differently, returns 0.  The @code{-ci} procedures don't distinguish
uppercase and lowercase letters.

@example
@group
(string-match-forward "mirror" "micro") @result{}  2  @r{; matches "mi"}
(string-match-forward "a" "b")          @result{}  0  @r{; no match}
@end group
@end example
@end deffn

@deffn procedure string-match-backward string1 string2
@deffnx procedure string-match-backward-ci string1 string2
Compares the two strings, starting from the end and matching toward
the front, returning the number of characters that are the same.  If
the two strings end differently, returns 0.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.

@example
@group
(string-match-backward-ci "BULBOUS" "fractious")
                                        @result{}  3  @r{; matches "ous"}
@end group
@end example
@end deffn

@deffn procedure string-prefix? string1 string2
@deffnx procedure string-prefix-ci? string1 string2
@cindex prefix, of string
These procedures return @code{#t} if the first string forms the prefix
of the second; otherwise returns @code{#f}.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.

@example
@group
(string-prefix? "abc" "abcdef")         @result{}  #t
(string-prefix? "" any-string)          @result{}  #t
@end group
@end example
@end deffn

@deffn procedure string-suffix? string1 string2
@deffnx procedure string-suffix-ci? string1 string2
@cindex suffix, of string
These procedures return @code{#t} if the first string forms the suffix
of the second; otherwise returns @code{#f}.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.

@example
@group
(string-suffix? "ous" "bulbous")        @result{}  #t
(string-suffix? "" any-string)          @result{}  #t
@end group
@end example
@end deffn

@node Regular Expressions, , Matching Strings, Strings
@section Regular Expressions

MIT/GNU Scheme provides support for using regular expressions to search and
match strings.  This manual does not define regular expressions; instead
see @ref{Regexps, , Syntax of Regular Expressions, emacs, The Emacs
Editor}.

In addition to providing standard regular-expression support, MIT/GNU
Scheme also provides the @acronym{REXP} abstraction.  This is an
alternative way to write regular expressions that is easier to read
and understand than the standard notation.  Regular expressions
written in this notation can be translated into the standard
notation.

The regular-expression support is a run-time-loadable option.  To use
it, execute

@example
(load-option 'regular-expression)
@end example

@noindent
once before calling any of the procedures defined here.

@menu
* Regular-expression procedures::
* REXP abstraction::
@end menu

@node Regular-expression procedures, REXP abstraction, Regular Expressions, Regular Expressions
@subsection Regular-expression procedures
@cindex searching, for regular expression
@cindex regular expression, searching string for

Procedures that perform regular-expression match and search accept
standardized arguments.  @var{Regexp} is the regular expression; it is
either a string representation of a regular expression, or a compiled
regular expression object.  @var{String} is the string being matched
or searched.  Procedures that operate on substrings also accept
@var{start} and @var{end} index arguments with the usual meaning.  The
optional argument @var{case-fold?} says whether the match/search is
case-sensitive; if @var{case-fold?} is @code{#f}, it is
case-sensitive, otherwise it is case-insensitive.  The optional
argument @var{syntax-table} is a character syntax table that defines
the character syntax, such as which characters are legal word
constituents.  This feature is primarily for Edwin, so character
syntax tables will not be documented here.  Supplying @code{#f} for
(or omitting) @var{syntax-table} will select the default character
syntax, equivalent to Edwin's @code{fundamental} mode.

@deffn procedure re-string-match regexp string [case-fold? [syntax-table]]
@deffnx procedure re-substring-match regexp string start end [case-fold? [syntax-table]]
These procedures match @var{regexp} against the respective string or
substring, returning @code{#f} for no match, or a set of match registers
(see below) if the match succeeds.  Here is an example showing how to
extract the matched substring:

@example
@group
(let ((r (re-substring-match @var{regexp} @var{string} @var{start} @var{end})))
  (and r
       (substring @var{string} @var{start} (re-match-end-index 0 r))))
@end group
@end example
@end deffn

@deffn procedure re-string-search-forward regexp string [case-fold? [syntax-table]]
@deffnx procedure re-substring-search-forward regexp string start end [case-fold? [syntax-table]]
Searches @var{string} for the leftmost substring matching @var{regexp}.
Returns a set of match registers (see below) if the search is
successful, or @code{#f} if it is unsuccessful.

@code{re-substring-search-forward} limits its search to the specified
substring of @var{string}; @code{re-string-search-forward} searches all
of @var{string}.
@end deffn

@deffn procedure re-string-search-backward regexp string [case-fold? [syntax-table]]
@deffnx procedure re-substring-search-backward regexp string start end [case-fold? [syntax-table]]
Searches @var{string} for the rightmost substring matching @var{regexp}.
Returns a set of match registers (see below) if the search is
successful, or @code{#f} if it is unsuccessful.

@code{re-substring-search-backward} limits its search to the specified
substring of @var{string}; @code{re-string-search-backward} searches all
of @var{string}.
@end deffn

When a successful match or search occurs, the above procedures return a
set of @dfn{match registers}.  The match registers are a set of index
registers that record indexes into the matched string.  Each index
register corresponds to an instance of the regular-expression grouping
operator @samp{\(}, and records the start index (inclusive) and end
index (exclusive) of the matched group.  These registers are numbered
from @code{1} to @code{9}, corresponding left-to-right to the grouping
operators in the expression.  Additionally, register @code{0}
corresponds to the entire substring matching the regular expression.

@deffn procedure re-match-start-index n registers
@deffnx procedure re-match-end-index n registers
@var{N} must be an exact integer between @code{0} and @code{9}
inclusive.  @var{Registers} must be a match-registers object as returned
by one of the regular-expression match or search procedures above.
@code{re-match-start-index} returns the start index of the corresponding
regular-expression register, and @code{re-match-end-index} returns the
corresponding end index.
@end deffn

@deffn procedure re-match-extract string registers n
@var{Registers} must be a match-registers object as returned by one of
the regular-expression match or search procedures above.  @var{String}
must be the string that was passed as an argument to the procedure that
returned @var{registers}.  @var{N} must be an exact integer between
@code{0} and @code{9} inclusive.  If the matched regular expression
contained @var{m} grouping operators, then the value of this procedure
is undefined for @var{n} strictly greater than @var{m}.

This procedure extracts the substring corresponding to the match
register specified by @var{registers} and @var{n}.  This is equivalent
to the following expression:

@example
@group
(substring @var{string}
           (re-match-start-index @var{n} @var{registers})
           (re-match-end-index @var{n} @var{registers}))
@end group
@end example
@end deffn

@deffn procedure regexp-group alternative @dots{}
Each @var{alternative} must be a string representation of a regular
expression.  The returned value is a new string representation of a
regular expression that consists of the @var{alternative}s combined by
a grouping operator.  For example:

@example
@group
(regexp-group "foo" "bar" "baz")
  @result{} "\\(foo\\|bar\\|baz\\)"
@end group
@end example
@end deffn

@deffn procedure re-compile-pattern regexp-string
@var{Regexp-string} must be the string representation of a regular
expression.  Returns a compiled regular expression object of the
represented regular expression.

Procedures that apply regular expressions, such as
@code{re-string-search-forward}, are sometimes faster when used with
compiled regular expression objects than when used with the string
representations of regular expressions, so applications that reuse
regular expressions may speed up matching and searching by caching the
compiled regular expression objects.  However, the regular expression
procedures have some internal caches as well, so this is likely to
improve performance only for applications that use a large number of
different regular expressions before cycling through the same ones
again.
@end deffn

@node REXP abstraction,  , Regular-expression procedures, Regular Expressions
@subsection REXP abstraction

@cindex REXP abstraction
In addition to providing standard regular-expression support, MIT/GNU
Scheme also provides the @acronym{REXP} abstraction.  This is an
alternative way to write regular expressions that is easier to read
and understand than the standard notation.  Regular expressions
written in this notation can be translated into the standard notation.

The @acronym{REXP} abstraction is a set of combinators that are
composed into a complete regular expression.  Each combinator directly
corresponds to a particular piece of regular-expression notation.  For
example, the expression @code{(rexp-any-char)} corresponds to the
@code{.} character in standard regular-expression notation, while
@code{(rexp* @var{rexp})} corresponds to the @code{*} character.

The primary advantages of @acronym{REXP} are that it makes the nesting
structure of regular expressions explicit, and that it simplifies the
description of complex regular expressions by allowing them to be
built up using straightforward combinators.

@deffn procedure rexp? object
Returns @code{#t} if @var{object} is a @acronym{REXP} expression, or
@code{#f} otherwise.  A @acronym{REXP} is one of: a string, which
represents the pattern matching that string; a character set, which
represents the pattern matching a character in that set; or an object
returned by calling one of the procedures defined here.
@end deffn

@deffn procedure rexp->regexp rexp
Converts @var{rexp} to standard regular-expression notation, returning
a newly-allocated string.
@end deffn

@deffn procedure rexp-compile rexp
Converts @var{rexp} to standard regular-expression notation, then
compiles it and returns the compiled result.  Equivalent to

@example
(re-compile-pattern (rexp->regexp @var{rexp}) #f)
@end example
@end deffn

@deffn procedure rexp-any-char
Returns a @acronym{REXP} that matches any single character except a
newline.  This is equivalent to the @code{.} construct.
@end deffn

@deffn procedure rexp-line-start
Returns a @acronym{REXP} that matches the start of a line.  This is
equivalent to the @code{^} construct.
@end deffn

@deffn procedure rexp-line-end
Returns a @acronym{REXP} that matches the end of a line.  This is
equivalent to the @code{$} construct.
@end deffn

@deffn procedure rexp-string-start
Returns a @acronym{REXP} that matches the start of the text being
matched.  This is equivalent to the @code{\`} construct.
@end deffn

@deffn procedure rexp-string-end
Returns a @acronym{REXP} that matches the end of the text being
matched.  This is equivalent to the @code{\'} construct.
@end deffn

@deffn procedure rexp-word-edge
Returns a @acronym{REXP} that matches the start or end of a word.
This is equivalent to the @code{\b} construct.
@end deffn

@deffn procedure rexp-not-word-edge
Returns a @acronym{REXP} that matches anywhere that is not the start
or end of a word.  This is equivalent to the @code{\B} construct.
@end deffn

@deffn procedure rexp-word-start
Returns a @acronym{REXP} that matches the start of a word.
This is equivalent to the @code{\<} construct.
@end deffn

@deffn procedure rexp-word-end
Returns a @acronym{REXP} that matches the end of a word.
This is equivalent to the @code{\>} construct.
@end deffn

@deffn procedure rexp-word-char
Returns a @acronym{REXP} that matches any word-constituent character.
This is equivalent to the @code{\w} construct.
@end deffn

@deffn procedure rexp-not-word-char
Returns a @acronym{REXP} that matches any character that isn't a word
constituent.  This is equivalent to the @code{\W} construct.
@end deffn

The next two procedures accept a @var{syntax-type} argument specifying
the syntax class to be matched against.  This argument is a symbol
selected from the following list.  Each symbol is followed by the
equivalent character used in standard regular-expression notation.
@code{whitespace} (space character),
@code{punctuation} (@code{.}),
@code{word} (@code{w}),
@code{symbol} (@code{_}),
@code{open} (@code{(}),
@code{close} (@code{)}),
@code{quote} (@code{'}),
@code{string-delimiter} (@code{"}),
@code{math-delimiter} (@code{$}),
@code{escape} (@code{\}),
@code{char-quote} (@code{/}),
@code{comment-start} (@code{<}),
@code{comment-end} (@code{>}).

@deffn procedure rexp-syntax-char syntax-type
Returns a @acronym{REXP} that matches any character of type
@var{syntax-type}.  This is equivalent to the @code{\s} construct.
@end deffn

@deffn procedure rexp-not-syntax-char syntax-type
Returns a @acronym{REXP} that matches any character not of type
@var{syntax-type}.  This is equivalent to the @code{\S} construct.
@end deffn

@deffn procedure rexp-sequence rexp @dots{}
Returns a @acronym{REXP} that matches each @var{rexp} argument in
sequence.  If no @var{rexp} argument is supplied, the result matches
the null string.  This is equivalent to concatenating the regular
expressions corresponding to each @var{rexp} argument.
@end deffn

@deffn procedure rexp-alternatives rexp @dots{}
Returns a @acronym{REXP} that matches any of the @var{rexp}
arguments.  This is equivalent to concatenating the regular
expressions corresponding to each @var{rexp} argument, separating them
by the @code{\|} construct.
@end deffn

@deffn procedure rexp-group rexp @dots{}
@code{rexp-group} is like @code{rexp-sequence}, except that the result
is marked as a match group.  This is equivalent to the @code{\(}
@dots{} @code{\)} construct.
@end deffn

The next three procedures in principal accept a single @acronym{REXP}
argument.  For convenience, they accept multiple arguments, which are
converted into a single argument by @code{rexp-group}.  Note, however,
that if only one @acronym{REXP} argument is supplied, and it's very
simple, no grouping occurs.

@deffn procedure rexp* rexp @dots{}
Returns a @acronym{REXP} that matches zero or more instances of the
pattern matched by the @var{rexp} arguments.  This is equivalent to
the @code{*} construct.
@end deffn

@deffn procedure rexp+ rexp @dots{}
Returns a @acronym{REXP} that matches one or more instances of the
pattern matched by the @var{rexp} arguments.  This is equivalent to
the @code{+} construct.
@end deffn

@deffn procedure rexp-optional rexp @dots{}
Returns a @acronym{REXP} that matches zero or one instances of the
pattern matched by the @var{rexp} arguments.  This is equivalent to
the @code{?} construct.
@end deffn

@deffn procedure rexp-case-fold rexp
Returns a @acronym{REXP} that matches the same pattern as @var{rexp},
but is insensitive to character case.  This has no equivalent in
standard regular-expression notation.
@end deffn
