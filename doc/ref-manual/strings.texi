@node Strings, Lists, Characters, Top
@chapter Strings

@menu
* Searching and Matching Strings::
* Regular Expressions::
@end menu

@cindex string, character (defn)
@cindex external representation, for string
@cindex " as external representation
@cindex double quote, as external representation
@cindex \ as escape character in string
@cindex backslash, as escape character in string
@cindex escape character, for string
@findex "
Strings are sequences of characters.  Strings are written as sequences
of characters enclosed within quotation marks (@code{"}).  Within a
string literal, various escape sequences represent characters other
than themselves.  Escape sequences always start with a backslash
(@code{\}):

@display
@group
@code{\a} : alarm, U+0007
@code{\b} : backspace, U+0008
@code{\t} : character tabulation, U+0009
@code{\n} : linefeed, U+000A
@code{\r} : return, U+000D
@code{\"} : double quote, U+0022
@code{\\} : backslash, U+005C
@code{\|} : vertical line, U+007C
@code{\}@var{intraline-whitespace}* @var{line-ending} @var{intraline-whitespace}*
     : nothing
@code{\x}@var{hex-scalar-value}@code{;}
     : specified character (note the terminating semi-colon).
@end group
@end display
@findex \a
@findex \b
@findex \t
@findex \n
@findex \r
@findex \"
@findex \\
@findex \|
@findex \x

The result is unspecified if any other character in a string occurs
after a backslash.

Except for a line ending, any character outside of an escape sequence
stands for itself in the string literal.  A line ending which is
preceded by @code{\}@var{intraline-whitespace} expands to nothing
(along with any trailing intraline whitespace), and can be used to
indent strings for improved legibility. Any other line ending has the
same effect as inserting a @code{\n} character into the string.

Examples:

@example
@group
"The word \"recursion\" has many meanings."
"Another example:\ntwo lines of text"
"Here's text \
   containing just one line"
"\x03B1; is named GREEK SMALL LETTER ALPHA."
@end group
@end example

@cindex length, of string (defn)
@cindex index, of string (defn)
@cindex valid index, of string (defn)
@cindex string length (defn)
@cindex string index (defn)
The @emph{length} of a string is the number of characters that it
contains.  This number is an exact, non-negative integer that is fixed
when the string is created.  The @dfn{valid indexes} of a string are
the exact non-negative integers less than the length of the string.
The first character of a string has index 0, the second has index 1,
and so on.

@cindex case sensitivity, of string operations
@cindex -ci, in string procedure name
Some of the procedures that operate on strings ignore the difference
between upper and lower case.  The names of the versions that ignore
case end with @samp{-ci} (for ``case insensitive'').

Implementations may forbid certain characters from appearing in
strings.  However, with the exception of @code{#\null},
@acronym{ASCII} characters must not be forbidden.  For example, an
implementation might support the entire Unicode repertoire, but only
allow characters U+0001 to U+00FF (the Latin-1 repertoire without
@code{#\null}) in strings.

Implementation note: MIT/GNU Scheme allows any ``bitless'' character
to be stored in a string.  In effect this means any character with a
Unicode code point, including surrogates.

It is an error to pass such a forbidden character to
@code{make-string}, @code{string}, @code{string-set!}, or
@code{string-fill!}, as part of the list passed to
@code{list->string}, or as part of the vector passed to
@code{vector->string}, or in UTF-8 encoded form within a bytevector
passed to @code{utf8->string}.  It is also an error for a procedure
passed to @code{string-map} to return a forbidden character, or for
@code{read-string} to attempt to read one.

@deffn {standard procedure} string? obj
Returns @code{#t} if @var{obj} is a string, otherwise returns @code{#f}.
@end deffn

@deffn {standard procedure} make-string k [char]
The @code{make-string} procedure returns a newly allocated string of
length @var{k}.  If @var{char} is given, then all the characters of the string
are initialized to @var{char}, otherwise the contents of the
string are unspecified.
@end deffn

@deffn {standard procedure} string char @dots{}
Returns a newly allocated string composed of the arguments.  It is
analogous to @code{list}.
@end deffn

@deffn {standard procedure} string-length string
Returns the number of characters in the given @var{string}.
@end deffn

@deffn {standard procedure} string-ref string k
It is an error if @var{k} is not a valid index of @var{string}.

The @code{string-ref} procedure returns character @var{k} of
@var{string} using zero-origin indexing.  There is no requirement for
this procedure to execute in constant time.
@end deffn

@deffn {standard procedure} string-set! string k char
It is an error if @var{k} is not a valid index of @var{string}.

The @code{string-set!} procedure stores @var{char} in element @var{k} of @var{string}.
There is no requirement for this procedure to execute in constant time.

@example
@group
(define (f) (make-string 3 #\*))
(define (g) "***")
(string-set! (f) 0 #\?)  @result{}  @r{@i{unspecified}}
(string-set! (g) 0 #\?)  @result{}  @r{@i{error}}
(string-set! (symbol->string 'immutable) 0 #\?)  @result{}  @r{@i{error}}
@end group
@end example
@end deffn

@deffn {standard procedure} string=? string1 string2 string @dots{}
Returns @code{#t} if all the strings are the same length and contain
exactly the same characters in the same positions, otherwise returns
@code{#f}.
@end deffn

@deffn {standard procedure} string-ci=? string1 string2 string @dots{}
Returns @code{#t} if, after case-folding, all the strings are the same
length and contain the same characters in the same positions,
otherwise returns @code{#f}.  Specifically, these procedures behave as
if @code{string-foldcase} were applied to their arguments before
comparing them.
@end deffn

@deffn {standard procedure} string<? string1 string2 string @dots{}
@deffnx {standard procedure} string-ci<? string1 string2 string @dots{}
@deffnx {standard procedure} string>? string1 string2 string @dots{}
@deffnx {standard procedure} string-ci>? string1 string2 string @dots{}
@deffnx {standard procedure} string<=? string1 string2 string @dots{}
@deffnx {standard procedure} string-ci<=? string1 string2 string @dots{}
@deffnx {standard procedure} string>=? string1 string2 string @dots{}
@deffnx {standard procedure} string-ci>=? string1 string2 string @dots{}
These procedures return @code{#t} if their arguments are (respectively):
monotonically increasing, monotonically decreasing,
monotonically non-decreasing, or monotonically non-increasing.

These predicates are required to be transitive.

These procedures compare strings in an implementation-defined way.
One approach is to make them the lexicographic extensions to strings
of the corresponding orderings on characters.  In that case,
@code{string<?}  would be the lexicographic ordering on strings
induced by the ordering @code{char<?} on characters, and if the two
strings differ in length but are the same up to the length of the
shorter string, the shorter string would be considered to be
lexicographically less than the longer string.  However, it is also
permitted to use the natural ordering imposed by the implementation's
internal representation of strings, or a more complex locale-specific
ordering.

In all cases, a pair of strings must satisfy exactly one of
@code{string<?}, @code{string=?}, and @code{string>?}, and must satisfy
@code{string<=?} if and only if they do not satisfy @code{string>?} and
@code{string>=?} if and only if they do not satisfy @code{string<?}.

The @samp{-ci} procedures behave as if they applied
@code{string-foldcase} to their arguments before invoking the
corresponding procedures without @samp{-ci}.
@end deffn

@deffn procedure string-compare string1 string2 if-eq if-lt if-gt
@deffnx procedure string-compare-ci string1 string2 if-eq if-lt if-gt
@var{If-eq}, @var{if-lt}, and @var{if-gt} are procedures of no arguments
(thunks).  The two strings are compared; if they are equal, @var{if-eq}
is applied, if @var{string1} is less than @var{string2}, @var{if-lt} is
applied, else if @var{string1} is greater than @var{string2},
@var{if-gt} is applied.  The value of the procedure is the value of the
thunk that is applied.

@code{string-compare} distinguishes uppercase and lowercase letters;@*
@code{string-compare-ci} does not.

@example
@group
(define (cheer) (display "Hooray!"))
(define (boo)   (display "Boo-hiss!"))
(string-compare "a" "b"  cheer  (lambda() 'ignore)  boo)
        @print{}  Hooray!
        @result{}  @r{unspecified}
@end group
@end example
@end deffn

@deffn {standard procedure} string-upcase string
@deffnx {standard procedure} string-downcase string
@deffnx procedure string-titlecase string
@deffnx {standard procedure} string-foldcase string
@deffnx procedure string-canonical-foldcase string
These procedures apply the Unicode full string uppercasing,
lowercasing, titlecasing, case-folding, and canonical case-folding
algorithms to their arguments and return the result.  In certain
cases, the result differs in length from the argument.  If the result
is equal to the argument in the sense of @code{string=?}, the argument
may be returned.  Note that language-sensitive mappings and foldings
are not used.

The Unicode Standard prescribes special treatment of the Greek letter
@math{\Sigma}, whose normal lower-case form is @math{\sigma} but which
becomes @math{\varsigma} at the end of a word.  See
@uref{http://www.unicode.org/reports/tr44/, UAX #44} (part of the
Unicode Standard) for details.  However, implementations of @code
{string-downcase} are not required to provide this behavior, and may
choose to change @math{\Sigma} to @math{\sigma} in all cases.
@end deffn

@deffn procedure string-upper-case? string
@deffnx procedure string-lower-case? string
These procedures return @code{#t} if all the letters in the string are
lower case or upper case, otherwise they return @code{#f}.  The string
must contain at least one letter or the procedures return @code{#f}.

@example
@group
(map string-upper-case? '(""    "A"    "art"  "Art"  "ART"))
                       @result{} (#f    #t     #f     #f     #t)
@end group
@end example
@end deffn

@deffn {standard procedure} substring string start end
The @code{substring} procedure returns a newly allocated string formed
from the characters of @var{string} beginning with index @var{start}
and ending with index @var{end}.

This is equivalent to calling @code{string-copy} with the same
arguments, but is provided for backward compatibility and stylistic
flexibility.
@end deffn

@deffn {standard procedure} string-append string @dots{}
@deffnx procedure string-append* strings
Returns a newly allocated string whose characters are the
concatenation of the characters in the given strings.

The non-standard procedure @code{string-append*} is identical to
@code{string-append} but takes a single argument that's a list of
strings, rather than multiple string arguments.
@end deffn

@deffn procedure string object @dots{}
@deffnx procedure string* objects
Returns a newly allocated string whose characters are the
concatenation of the characters from the given objects.

Unlike @code{string-append}, each @var{object} may be one of several
types:

@itemize @bullet
@item
A string
@item
@code{#f}, equivalent to an empty string.
@item
A bitless character, equivalent to a string containing that character.
@item
A symbol, equivalent to the result of @code{symbol->string}.
@item
A number, equivalent to the result of @code{number->string}.
@item
A @acronym{URI}, equivalent to the result of @code{uri->string}.
@item
A pathname, equivalent to the result of @code{->namestring}.
@end itemize

The procedure @code{string*} is identical to @code{string} but takes a
single argument that's a list of objects, rather than multiple object
arguments.
@end deffn

@deffn {standard procedure} string->list string [start [end]]
@deffnx {standard procedure} list->string list
It is an error if any element of @var{list} is not a character.

The @code{string->list} procedure returns a newly allocated list of
the characters of @var{string} between @var{start} and @var{end}.
@code{list->string} returns a newly allocated string formed from the
elements in the list @var{list}.  In both procedures, order is
preserved.  @code{string->list} and @code{list->string} are inverses
so far as @code{equal?} is concerned.
@end deffn

@deffn {standard procedure} string-copy string [start [end]]
Returns a newly allocated copy of the part of the given @var{string}
between @var{start} and @var{end}.
@end deffn

@deffn {standard procedure} string-copy! to at from [start [end]]
It is an error if @var{at} is less than zero or greater than the
length of @var{to}.  It is also an error if @code{(- (string-length
@var{to}) @var{at})} is less than @code{(- @var{end} @var{start})}.

Copies the characters of string @var{from} between @var{start} and
@var{end} to string @var{to}, starting at @var{at}.  The order in
which characters are copied is unspecified, except that if the source
and destination overlap, copying takes place as if the source is first
copied into a temporary string and then into the destination.  This
can be achieved without allocating storage by making sure to copy in
the correct direction in such circumstances.

@example
@group
(define a "12345")
(define b (string-copy "abcde"))
(string-copy! b 1 a 0 2)
b @result{} "a12de"%
@end group
@end example
@end deffn

@deffn {standard procedure} string-fill! string fill [start [end]]
It is an error if @var{fill} is not a character.

The @code{string-fill!} procedure stores @var{fill} in the elements of
@var{string} between @var{start} and @var{end}.
@end deffn

@deffn procedure string-slice string [start [end]]
@cindex slice, of string
@cindex string slice
Returns a @dfn{slice} of @var{string}, restricted to the range of
characters specified by @var{start} and @var{end}.

A slice is a kind of string that provides a view into another string.
The slice behaves like any other string, but changes to a slice are
reflected in the original string and vice versa.

@example
@group
(define foo (string #\a #\b #\c #\d #\e))
foo @result{} "abcde"

(define bar (string-slice foo 1 4))
bar @result{} "bcd"

(string-set! foo 2 #\z)
foo @result{} "abzde"
bar @result{} "bzd"

(string-set! bar 1 #\y)
bar @result{} "byd"
foo @result{} "abyde"
@end group
@end example
@end deffn

@cindex grapheme cluster
The next two procedures treat a given string as a sequence of
@dfn{grapheme clusters}, a concept defined by the Unicode standard in
@uref{http://www.unicode.org/reports/tr29/tr29-29.html, UAX #29}:

@quotation
It is important to recognize that what the user thinks of as a
``character''---a basic unit of a writing system for a language---may
not be just a single Unicode code point.  Instead, that basic unit may
be made up of multiple Unicode code points.  To avoid ambiguity with
the computer use of the term character, this is called a
user-perceived character.  For example, “G” + acute-accent is a
user-perceived character: users think of it as a single character, yet
is actually represented by two Unicode code points.  These
user-perceived characters are approximated by what is called a
grapheme cluster, which can be determined programmatically.
@end quotation

@deffn procedure grapheme-cluster-length string
This procedure returns the number of grapheme clusters in
@var{string}.

For @acronym{ASCII} strings, this is identical to
@code{string-length}.
@end deffn

@deffn procedure grapheme-cluster-slice string start end
This procedure slices @var{string} at the grapheme-cluster boundaries
specified by the @var{start} and @var{end} indices.  These indices are
grapheme-cluster indices, @emph{not} normal string indices.

For @acronym{ASCII} strings, this is identical to @code{string-slice}.
@end deffn

@deffn {standard procedure} string-map proc string string @dots{}
It is an error if @var{proc} does not accept as many arguments as
there are @var{string}s and return a single character.

The @code{string-map} procedure applies @var{proc} element-wise to the
elements of the @var{string}s and returns a string of the results, in
order.  If more than one @var{string} is given and not all strings
have the same length, @code{string-map} terminates when the shortest
string runs out.  The dynamic order in which @var{proc} is applied to
the elements of the @var{string}s is unspecified.  If multiple returns
occur from @code{string-map}, the values returned by earlier returns
are not mutated.

@example
(string-map char-foldcase "AbdEgH")  @result{}  "abdegh"

(string-map
 (lambda (c)
   (integer->char (+ 1 (char->integer c))))
 "HAL")                 @result{}  "IBM"

(string-map
 (lambda (c k)
   ((if (eqv? k #\u) char-upcase char-downcase) c))
 "studlycaps xxx"
 "ululululul")          @result{}  "StUdLyCaPs"
@end example
@end deffn

@deffn {standard procedure} string-for-each proc string string @dots{}
It is an error if @var{proc} does not
accept as many arguments as there are @var{string}s.

The arguments to @code{string-for-each} are like the arguments to
@code{string-map}, but @code{string-for-each} calls @var{proc} for its
side effects rather than for its values.  Unlike @code{string-map},
@code{string-for-each} is guaranteed to call @var{proc} on the elements
of the @var{list}s in order from the first element(s) to the last, and
the value returned by @code{string-for-each} is unspecified.  If more
than one @var{string} is given and not all strings have the same
length, @code{string-for-each} terminates when the shortest string
runs out.  It is an error for @var{proc} to mutate any of the strings.

@example
(let ((v '()))
  (string-for-each
   (lambda (c) (set! v (cons (char->integer c) v)))
   "abcde")
  v)                    @result{}  (101 100 99 98 97)
@end example
@end deffn

@deffn procedure string-count proc string string @dots{}
It is an error if @var{proc} does not accept as many arguments as
there are @var{string}s.

The @code{string-count} procedure applies @var{proc} element-wise to the
elements of the @var{string}s and returns a count of the number of
true values it returns.  If more than one @var{string} is given and not all strings
have the same length, @code{string-count} terminates when the shortest
string runs out.  The dynamic order in which @var{proc} is applied to
the elements of the @var{string}s is unspecified.
@end deffn

@deffn procedure string-any proc string string @dots{}
It is an error if @var{proc} does not accept as many arguments as
there are @var{string}s.

The @code{string-any} procedure applies @var{proc} element-wise to the
elements of the @var{string}s and returns @code{#t} if it returns a
true value.  If @var{proc} doesn't return a true value,
@code{string-any} returns @code{#f}.

If more than one @var{string} is given and not all strings have the
same length, @code{string-any} terminates when the shortest string
runs out.  The dynamic order in which @var{proc} is applied to the
elements of the @var{string}s is unspecified.
@end deffn

@deffn procedure string-every proc string string @dots{}
It is an error if @var{proc} does not accept as many arguments as
there are @var{string}s.

The @code{string-every} procedure applies @var{proc} element-wise to the
elements of the @var{string}s and returns @code{#f} if it returns a
false value.  If @var{proc} doesn't return a false value,
@code{string-every} returns @code{#t}.

If more than one @var{string} is given and not all strings have the
same length, @code{string-every} terminates when the shortest string
runs out.  The dynamic order in which @var{proc} is applied to the
elements of the @var{string}s is unspecified.
@end deffn

@deffn procedure string-null? string
@cindex empty string, predicate for
@cindex null string, predicate for
Returns @code{#t} if @var{string} has zero length; otherwise returns
@code{#f}.

@example
@group
(string-null? "")       @result{}  #t
(string-null? "Hi")     @result{}  #f
@end group
@end example
@end deffn

@deffn procedure string-hash string [modulus]
@deffnx procedure string-hash-ci string [modulus]
@cindex hashing, of string
@findex string=?
@findex string-ci=?
@findex =
These procedures return an exact non-negative integer that can be used
for storing the specified @var{string} in a hash table.  Equal strings
(in the sense of @code{string=?} and @code{string-ci=?} respectively)
return equal (@code{=}) hash codes, and non-equal but similar strings
are usually mapped to distinct hash codes.

If the optional argument @var{modulus} is specified, it must be an
exact positive integer, and the result of the hash computation is
restricted to be less than that value.  This is equivalent to calling
@code{modulo} on the result, but may be faster.
@end deffn

@deffn procedure string-head string end
Equivalent to @code{(string-copy @var{string} 0 @var{end})}.
@end deffn

@deffn procedure string-tail string start
Equivalent to @code{(string-copy @var{string} @var{start})}.
@end deffn

@deffn procedure string-joiner infix prefix suffix
@deffnx procedure string-joiner* infix prefix suffix
@cindex joining, of strings
This procedure's arguments are keyword arguments; that is, each
argument is a symbol of the same name followed by its value.  The
order of the arguments doesn't matter, but each argument may appear
only once.

@cindex joiner procedure
These procedures return a @dfn{joiner} procedure that takes multiple
strings and joins them together into a newly allocated string.  The
joiner returned by @code{string-joiner} accepts these strings as
multiple string arguments, while @code{string-joiner*} accepts the
strings as a single list-valued argument.

The joiner produces a result by adding @var{prefix} before,
@var{suffix} after, and @var{infix} between each input string, then
concatenating everything together into a single string.  Each of the
@var{prefix}, @var{suffix}, and @var{infix} arguments is optional and
defaults to an empty string, so normally at least one is specified.

Some examples:
@example
((string-joiner) "a" "b" "c")
  @result{}  "abc"

((string-joiner 'infix " ") "a" "b" "c")
  @result{}  "a b c"

((string-joiner 'infix ", ") "a" "b" "c")
  @result{}  "a, b, c"

((string-joiner* 'infix ", " 'prefix "<" 'suffix ">")
 '("a" "b" "c"))
  @result{}  "<a>, <b>, <c>"
@end example
@end deffn

@deffn procedure string-splitter delimiter allow-runs? copy?
@cindex splitting, of string
This procedure's arguments are keyword arguments; that is, each
argument is a symbol of the same name followed by its value.  The
order of the arguments doesn't matter, but each argument may appear
only once.

@cindex splitter procedure
This procedure returns a @dfn{splitter} procedure that splits a given
string into parts, returning a list of the parts.  This is done by
identifying delimiter characters and breaking the string at those
delimiters.  The splitting process is controlled by the arguments:

@itemize @bullet
@item
@var{delimiter} is either a character, a character set, or more
generally a procedure that accepts a single character argument and
returns a boolean value.  The splitter uses this to identify
delimiters in the string.  The default value of this argument is
@code{char-whitespace?}.
@item
@var{allow-runs?} is a boolean that controls what happens when two or
more adjacent delimiters are found.  If @var{allow-runs?} is
@code{#t}, then all of the adjacent delimiters are treated as if they
were a single delimiter, and the string is split at the beginning and
end of the delimiters.  If @var{allow-runs?} is @code{#f}, then
adjacent delimiters are treated as if they were separate with an empty
string between them.  The default value of this argument is @code{#t}.
@item
@code{copy?} is a boolean: if it is @code{#t}, then the returned
strings are newly allocated copies, but if it is @code{#f} the
returned strings are slices of the original string.  The default value
of this argument is @code{#f}.
@end itemize

Some examples:
@example
((string-splitter) "a b c")
  @result{}  ("a" "b" "c")

((string-splitter) "a\tb\tc")
  @result{}  ("a" "b" "c")

((string-splitter 'delimiter #\space) "a\tb\tc")
  @result{}  ("a\tb\tc")

((string-splitter) " a  b  c ")
  @result{}  ("a" "b" "c")

((string-splitter 'allow-runs? #f) " a  b  c ")
  @result{}  ("" "a" "" "b" "" "c" "")
@end example
@end deffn

@deffn procedure string-padder where fill-with clip?
@cindex padding, of string
This procedure's arguments are keyword arguments; that is, each
argument is a symbol of the same name followed by its value.  The
order of the arguments doesn't matter, but each argument may appear
only once.

@cindex padder procedure
This procedure returns a @dfn{padder} procedure that takes a string
and a grapheme-cluster length as its arguments and returns a new
string that has been padded to that length.  The padder adds grapheme
clusters to the string until it has the specified length.  If the
string's grapheme-cluster length is greater than the given length, the
string may, depending on the arguments, be reduced to the specified
length.

The padding process is controlled by the arguments:

@itemize @bullet
@item
@findex leading
@findex trailing
@var{where} is a symbol: either @code{leading} or @code{trailing},
which directs the padder to add/remove leading or trailing grapheme
clusters.  The default value of this argument is @code{leading}.
@item
@findex fill-with
@var{fill-with} is a string that contains exactly one grapheme
cluster, which is used as the padding to increase the size of the
string.  The default value of this argument is @code{" "} (a single
space character).
@item
@var{clip?} is a boolean that controls what happens if the given
string has a longer grapheme-cluster length than the given length.  If
@code{clip?} is @code{#t}, grapheme clusters are removed (by slicing)
from the string until it is the correct length; if it is @code{#f}
then the string is returned unchanged.  The grapheme clusters are
removed from the beginning of the string if @code{where} is
@code{leading}, otherwise from the end of the string.
@end itemize

Some examples:
@example
((string-padder) "abc def" 10)
  @result{}  "   abc def"

((string-padder 'where 'trailing) "abc def" 10)
  @result{}  "abc def   "

((string-padder 'fill-with "X") "abc def" 10)
  @result{}  "XXXabc def"

((string-padder) "abc def" 5)
  @result{}  "c def"

((string-padder 'where 'trailing) "abc def" 5)
  @result{}  "abc d"

((string-padder 'clip? #f) "abc def" 5)
  @result{}  "abc def"
@end example
@end deffn

@deffn {obsolete procedure} string-pad-left string k [char]
@deffnx {obsolete procedure} string-pad-right string k [char]
These procedures are @strong{deprecated} and should be replaced by use
of @code{string-padder} which is more flexible.

@findex #\space
These procedures return a newly allocated string created by padding
@var{string} out to length @var{k}, using @var{char}.  If @var{char} is
not given, it defaults to @code{#\space}.  If @var{k} is less than the
length of @var{string}, the resulting string is a truncated form of
@var{string}.  @code{string-pad-left} adds padding characters or
truncates from the beginning of the string (lowest indices), while
@code{string-pad-right} does so at the end of the string (highest
indices).

@example
@group
(string-pad-left "hello" 4)             @result{}  "ello"
(string-pad-left "hello" 8)             @result{}  "   hello"
(string-pad-left "hello" 8 #\*)         @result{}  "***hello"
(string-pad-right "hello" 4)            @result{}  "hell"
(string-pad-right "hello" 8)            @result{}  "hello   "
@end group
@end example
@end deffn

@deffn procedure string-trimmer where trim-char? copy?
@cindex trimming, of string
This procedure's arguments are keyword arguments; that is, each
argument is a symbol of the same name followed by its value.  The
order of the arguments doesn't matter, but each argument may appear
only once.

@cindex trimmer procedure
This procedure returns a @dfn{trimmer} procedure that takes a string as
its argument and trims that string, returning the trimmed result.  The
trimming process is controlled by the arguments:

@itemize @bullet
@item
@findex leading
@findex trailing
@findex both
@var{where} is a symbol: either @code{leading}, @code{trailing}, or
@code{both}, which directs the trimmer to trim leading characters,
trailing characters, or both.  The default value of this argument is
@code{both}.
@item
@findex char-whitespace?
@var{trim-char?} is a procedure that accepts a single character
argument and returns a true value for a character that should be
removed by the trimmer, or a false value for a character that should
be retained.  The default value of this argument is @code{char-whitespace?}.
@item
@var{copy?} is a boolean: if @code{#t}, the trimmer returns a copy of
the trimmed string, if @code{#f} it returns a slice.  The default value
of this argument is @code{#f}.
@end itemize

Some examples:
@example
((string-trimmer 'where 'leading) "    ABC   DEF    ")
  @result{}  "ABC   DEF    "

((string-trimmer 'where 'trailing) "    ABC   DEF    ")
  @result{}  "    ABC   DEF"

((string-trimmer 'where 'both) "    ABC   DEF    ")
  @result{}  "ABC   DEF"

((string-trimmer) "    ABC   DEF    ")
  @result{}  "ABC   DEF"

((string-trimmer 'trim-char? char-numeric? 'where 'leading)
 "21 East 21st Street #3")
  @result{}  " East 21st Street #3"

((string-trimmer 'trim-char? char-numeric? 'where 'trailing)
 "21 East 21st Street #3")
  @result{}  "21 East 21st Street #"

((string-trimmer 'trim-char? char-numeric?)
 "21 East 21st Street #3")
  @result{}  " East 21st Street #"
@end example
@end deffn

@deffn {obsolete procedure} string-trim string [char-set]
@deffnx {obsolete procedure} string-trim-left string [char-set]
@deffnx {obsolete procedure} string-trim-right string [char-set]
These procedures are @strong{deprecated} and should be replaced by use
of @code{string-trimmer} which is more flexible.

@findex char-set:whitespace
Returns a newly allocated string created by removing all characters that
are not in @var{char-set} from: (@code{string-trim}) both ends of
@var{string}; (@code{string-trim-left}) the beginning of @var{string};
or (@code{string-trim-right}) the end of @var{string}.  @var{Char-set}
defaults to @code{char-set:not-whitespace}.

@example
@group
(string-trim "  in the end  ")          @result{}  "in the end"
(string-trim "              ")          @result{}  ""
(string-trim "100th" char-set:numeric)  @result{}  "100"
(string-trim-left "-.-+-=-" (char-set #\+))
                                        @result{}  "+-=-"
(string-trim "but (+ x y) is" (char-set #\( #\)))
                                        @result{}  "(+ x y)"
@end group
@end example
@end deffn

@deffn procedure string-replace string char1 char2
Returns a newly allocated string containing the same characters as
@var{string} except that all instances of @var{char1} have been
replaced by @var{char2}.
@end deffn

@node Searching and Matching Strings, Regular Expressions, Strings, Strings
@section Searching and Matching Strings
@cindex searching, of string
@cindex matching, of strings
@cindex character, searching string for
@cindex string, searching string for

This section describes procedures for searching a string, either for a
character or a substring, and matching two strings to one another.

@deffn procedure string-search-forward pattern string [start [end]]
@var{Pattern} must be a string.  Searches @var{string} for the leftmost
occurrence of the substring @var{pattern}.  If successful, the index of
the first character of the matched substring is returned; otherwise,
@code{#f} is returned.

@example
@group
(string-search-forward "rat" "pirate")
    @result{} 2
(string-search-forward "rat" "pirate rating")
    @result{} 2
(string-search-forward "rat" "pirate rating" 4 13)
    @result{} 7
(string-search-forward "rat" "pirate rating" 9 13)
    @result{} #f
@end group
@end example
@end deffn

@deffn procedure string-search-backward pattern string [start [end]]
@var{Pattern} must be a string.  Searches @var{string} for the rightmost
occurrence of the substring @var{pattern}.  If successful, the index to
the right of the last character of the matched substring is returned;
otherwise, @code{#f} is returned.

@example
@group
(string-search-backward "rat" "pirate")
    @result{} 5
(string-search-backward "rat" "pirate rating")
    @result{} 10
(string-search-backward "rat" "pirate rating" 1 8)
    @result{} 5
(string-search-backward "rat" "pirate rating" 9 13)
    @result{} #f
@end group
@end example
@end deffn

@deffn procedure string-search-all pattern string [start [end]]
@var{Pattern} must be a string.  Searches @var{string} to find all
occurrences of the substring @var{pattern}.  Returns a list of the
occurrences; each element of the list is an index pointing to the first
character of an occurrence.

@example
@group
(string-search-all "rat" "pirate")
    @result{} (2)
(string-search-all "rat" "pirate rating")
    @result{} (2 7)
(string-search-all "rat" "pirate rating" 4 13)
    @result{} (7)
(string-search-all "rat" "pirate rating" 9 13)
    @result{} ()
@end group
@end example
@end deffn

@deffn procedure substring? pattern string
@var{Pattern} must be a string.  Searches @var{string} to see if it
contains the substring @var{pattern}.  Returns @code{#t} if
@var{pattern} is a substring of @var{string}, otherwise returns
@code{#f}.

@example
@group
(substring? "rat" "pirate")             @result{}  #t
(substring? "rat" "outrage")            @result{}  #f
(substring? "" any-string)              @result{}  #t
(if (substring? "moon" text)
    (process-lunar text)
    'no-moon)
@end group
@end example
@end deffn

@deffn procedure string-find-first-index proc string string @dots{}
@deffnx procedure string-find-last-index proc string string @dots{}
It is an error if @var{proc} does not accept as many arguments as
there are @var{string}s.

These procedures apply @var{proc} element-wise to the elements of the
@var{string}s and return the first or last index for which @var{proc}
returns a true value.  If there is no such index, then @code{#f} is
returned.

If more than one @var{string} is given and not all strings have the
same length, then only the indexes of the shortest string are tested.
@end deffn

@deffn procedure string-find-next-char string char [start [end]]
@deffnx procedure string-find-next-char-ci string char [start [end]]
@deffnx procedure string-find-next-char-in-set string char-set [start [end]]
These procedures search @var{string} for a matching character,
starting from @var{start} and moving forwards to @var{end}.  If there
is a matching character, the procedures stop the search and return the
index of that character.  If there is no matching character, the
procedures return @code{#f}.

The procedures differ only in how they match characters:
@code{string-find-next-char} matches a character that is @code{char=?}
to @var{char}; @code{string-find-next-char-ci} matches a character
that is @code{char-ci=?} to @var{char}; and
@code{string-find-next-char-in-set} matches a character that's a
member of @var{char-set}.

@example
@group
(string-find-next-char "Adam" #\A)           @result{}  0 
(string-find-next-char "Adam" #\A 1 4)       @result{}  #f
(string-find-next-char-ci "Adam" #\A 1 4)    @result{}  2 
(string-find-next-char-in-set my-string char-set:alphabetic)
    @result{}  @r{start position of the first word in} my-string
@r{; Can be used as a predicate:}
(if (string-find-next-char-in-set my-string
                                  (char-set #\( #\) ))
    'contains-parentheses
    'no-parentheses)
@end group
@end example
@end deffn

@deffn procedure string-find-previous-char string char [start [end]]
@deffnx procedure string-find-previous-char-ci string char [start [end]]
@deffnx procedure string-find-previous-char-in-set string char-set [start [end]]
These procedures search @var{string} for a matching character,
starting from @var{end} and moving backwards to @var{start}.  If there
is a matching character, the procedures stop the search and return the
index of that character.  If there is no matching character, the
procedures return @code{#f}.

The procedures differ only in how they match characters:
@code{string-find-previous-char} matches a character that is
@code{char=?}  to @var{char}; @code{string-find-previous-char-ci}
matches a character that is @code{char-ci=?} to @var{char}; and
@code{string-find-previous-char-in-set} matches a character that's a
member of @var{char-set}.
@end deffn

@deffn procedure string-match-forward string1 string2
@deffnx procedure string-match-forward-ci string1 string2
Compares the two strings, starting from the beginning, and returns the
number of characters that are the same.  If the two strings start
differently, returns 0.  The @code{-ci} procedures don't distinguish
uppercase and lowercase letters.

@example
@group
(string-match-forward "mirror" "micro") @result{}  2  @r{; matches "mi"}
(string-match-forward "a" "b")          @result{}  0  @r{; no match}
@end group
@end example
@end deffn

@deffn procedure string-match-backward string1 string2
@deffnx procedure string-match-backward-ci string1 string2
Compares the two strings, starting from the end and matching toward
the front, returning the number of characters that are the same.  If
the two strings end differently, returns 0.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.

@example
@group
(string-match-backward-ci "BULBOUS" "fractious")
                                        @result{}  3  @r{; matches "ous"}
@end group
@end example
@end deffn

@deffn procedure string-prefix? string1 string2
@deffnx procedure string-prefix-ci? string1 string2
@cindex prefix, of string
These procedures return @code{#t} if the first string forms the prefix
of the second; otherwise returns @code{#f}.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.

@example
@group
(string-prefix? "abc" "abcdef")         @result{}  #t
(string-prefix? "" any-string)          @result{}  #t
@end group
@end example
@end deffn

@deffn procedure string-suffix? string1 string2
@deffnx procedure string-suffix-ci? string1 string2
@cindex suffix, of string
These procedures return @code{#t} if the first string forms the suffix
of the second; otherwise returns @code{#f}.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.

@example
@group
(string-suffix? "ous" "bulbous")        @result{}  #t
(string-suffix? "" any-string)          @result{}  #t
@end group
@end example
@end deffn

@node Regular Expressions,  , Searching and Matching Strings, Strings
@section Regular Expressions

MIT/GNU Scheme provides support for using regular expressions to search and
match strings.  This manual does not define regular expressions; instead
see @ref{Regexps, , Syntax of Regular Expressions, emacs, The Emacs
Editor}.

In addition to providing standard regular-expression support, MIT/GNU
Scheme also provides the @acronym{REXP} abstraction.  This is an
alternative way to write regular expressions that is easier to read
and understand than the standard notation.  Regular expressions
written in this notation can be translated into the standard
notation.

The regular-expression support is a run-time-loadable option.  To use
it, execute

@example
(load-option 'regular-expression)
@end example

@noindent
once before calling any of the procedures defined here.

@menu
* Regular-expression procedures::
* REXP abstraction::
@end menu

@node Regular-expression procedures, REXP abstraction, Regular Expressions, Regular Expressions
@subsection Regular-expression procedures
@cindex searching, for regular expression
@cindex regular expression, searching string for

Procedures that perform regular-expression match and search accept
standardized arguments.  @var{Regexp} is the regular expression; it is
either a string representation of a regular expression, or a compiled
regular expression object.  @var{String} is the string being matched
or searched.  Procedures that operate on substrings also accept
@var{start} and @var{end} index arguments with the usual meaning.  The
optional argument @var{case-fold?} says whether the match/search is
case-sensitive; if @var{case-fold?} is @code{#f}, it is
case-sensitive, otherwise it is case-insensitive.  The optional
argument @var{syntax-table} is a character syntax table that defines
the character syntax, such as which characters are legal word
constituents.  This feature is primarily for Edwin, so character
syntax tables will not be documented here.  Supplying @code{#f} for
(or omitting) @var{syntax-table} will select the default character
syntax, equivalent to Edwin's @code{fundamental} mode.

@deffn procedure re-string-match regexp string [case-fold? [syntax-table]]
@deffnx procedure re-substring-match regexp string start end [case-fold? [syntax-table]]
These procedures match @var{regexp} against the respective string or
substring, returning @code{#f} for no match, or a set of match registers
(see below) if the match succeeds.  Here is an example showing how to
extract the matched substring:

@example
@group
(let ((r (re-substring-match @var{regexp} @var{string} @var{start} @var{end})))
  (and r
       (substring @var{string} @var{start} (re-match-end-index 0 r))))
@end group
@end example
@end deffn

@deffn procedure re-string-search-forward regexp string [case-fold? [syntax-table]]
@deffnx procedure re-substring-search-forward regexp string start end [case-fold? [syntax-table]]
Searches @var{string} for the leftmost substring matching @var{regexp}.
Returns a set of match registers (see below) if the search is
successful, or @code{#f} if it is unsuccessful.

@code{re-substring-search-forward} limits its search to the specified
substring of @var{string}; @code{re-string-search-forward} searches all
of @var{string}.
@end deffn

@deffn procedure re-string-search-backward regexp string [case-fold? [syntax-table]]
@deffnx procedure re-substring-search-backward regexp string start end [case-fold? [syntax-table]]
Searches @var{string} for the rightmost substring matching @var{regexp}.
Returns a set of match registers (see below) if the search is
successful, or @code{#f} if it is unsuccessful.

@code{re-substring-search-backward} limits its search to the specified
substring of @var{string}; @code{re-string-search-backward} searches all
of @var{string}.
@end deffn

When a successful match or search occurs, the above procedures return a
set of @dfn{match registers}.  The match registers are a set of index
registers that record indexes into the matched string.  Each index
register corresponds to an instance of the regular-expression grouping
operator @samp{\(}, and records the start index (inclusive) and end
index (exclusive) of the matched group.  These registers are numbered
from @code{1} to @code{9}, corresponding left-to-right to the grouping
operators in the expression.  Additionally, register @code{0}
corresponds to the entire substring matching the regular expression.

@deffn procedure re-match-start-index n registers
@deffnx procedure re-match-end-index n registers
@var{N} must be an exact integer between @code{0} and @code{9}
inclusive.  @var{Registers} must be a match-registers object as returned
by one of the regular-expression match or search procedures above.
@code{re-match-start-index} returns the start index of the corresponding
regular-expression register, and @code{re-match-end-index} returns the
corresponding end index.
@end deffn

@deffn procedure re-match-extract string registers n
@var{Registers} must be a match-registers object as returned by one of
the regular-expression match or search procedures above.  @var{String}
must be the string that was passed as an argument to the procedure that
returned @var{registers}.  @var{N} must be an exact integer between
@code{0} and @code{9} inclusive.  If the matched regular expression
contained @var{m} grouping operators, then the value of this procedure
is undefined for @var{n} strictly greater than @var{m}.

This procedure extracts the substring corresponding to the match
register specified by @var{registers} and @var{n}.  This is equivalent
to the following expression:

@example
@group
(substring @var{string}
           (re-match-start-index @var{n} @var{registers})
           (re-match-end-index @var{n} @var{registers}))
@end group
@end example
@end deffn

@deffn procedure regexp-group alternative @dots{}
Each @var{alternative} must be a string representation of a regular
expression.  The returned value is a new string representation of a
regular expression that consists of the @var{alternative}s combined by
a grouping operator.  For example:

@example
@group
(regexp-group "foo" "bar" "baz")
  @result{} "\\(foo\\|bar\\|baz\\)"
@end group
@end example
@end deffn

@deffn procedure re-compile-pattern regexp-string
@var{Regexp-string} must be the string representation of a regular
expression.  Returns a compiled regular expression object of the
represented regular expression.

Procedures that apply regular expressions, such as
@code{re-string-search-forward}, are sometimes faster when used with
compiled regular expression objects than when used with the string
representations of regular expressions, so applications that reuse
regular expressions may speed up matching and searching by caching the
compiled regular expression objects.  However, the regular expression
procedures have some internal caches as well, so this is likely to
improve performance only for applications that use a large number of
different regular expressions before cycling through the same ones
again.
@end deffn

@node REXP abstraction,  , Regular-expression procedures, Regular Expressions
@subsection REXP abstraction

@cindex REXP abstraction
In addition to providing standard regular-expression support, MIT/GNU
Scheme also provides the @acronym{REXP} abstraction.  This is an
alternative way to write regular expressions that is easier to read
and understand than the standard notation.  Regular expressions
written in this notation can be translated into the standard notation.

The @acronym{REXP} abstraction is a set of combinators that are
composed into a complete regular expression.  Each combinator directly
corresponds to a particular piece of regular-expression notation.  For
example, the expression @code{(rexp-any-char)} corresponds to the
@code{.} character in standard regular-expression notation, while
@code{(rexp* @var{rexp})} corresponds to the @code{*} character.

The primary advantages of @acronym{REXP} are that it makes the nesting
structure of regular expressions explicit, and that it simplifies the
description of complex regular expressions by allowing them to be
built up using straightforward combinators.

@deffn procedure rexp? object
Returns @code{#t} if @var{object} is a @acronym{REXP} expression, or
@code{#f} otherwise.  A @acronym{REXP} is one of: a string, which
represents the pattern matching that string; a character set, which
represents the pattern matching a character in that set; or an object
returned by calling one of the procedures defined here.
@end deffn

@deffn procedure rexp->regexp rexp
Converts @var{rexp} to standard regular-expression notation, returning
a newly-allocated string.
@end deffn

@deffn procedure rexp-compile rexp
Converts @var{rexp} to standard regular-expression notation, then
compiles it and returns the compiled result.  Equivalent to

@example
(re-compile-pattern (rexp->regexp @var{rexp}) #f)
@end example
@end deffn

@deffn procedure rexp-any-char
Returns a @acronym{REXP} that matches any single character except a
newline.  This is equivalent to the @code{.} construct.
@end deffn

@deffn procedure rexp-line-start
Returns a @acronym{REXP} that matches the start of a line.  This is
equivalent to the @code{^} construct.
@end deffn

@deffn procedure rexp-line-end
Returns a @acronym{REXP} that matches the end of a line.  This is
equivalent to the @code{$} construct.
@end deffn

@deffn procedure rexp-string-start
Returns a @acronym{REXP} that matches the start of the text being
matched.  This is equivalent to the @code{\`} construct.
@end deffn

@deffn procedure rexp-string-end
Returns a @acronym{REXP} that matches the end of the text being
matched.  This is equivalent to the @code{\'} construct.
@end deffn

@deffn procedure rexp-word-edge
Returns a @acronym{REXP} that matches the start or end of a word.
This is equivalent to the @code{\b} construct.
@end deffn

@deffn procedure rexp-not-word-edge
Returns a @acronym{REXP} that matches anywhere that is not the start
or end of a word.  This is equivalent to the @code{\B} construct.
@end deffn

@deffn procedure rexp-word-start
Returns a @acronym{REXP} that matches the start of a word.
This is equivalent to the @code{\<} construct.
@end deffn

@deffn procedure rexp-word-end
Returns a @acronym{REXP} that matches the end of a word.
This is equivalent to the @code{\>} construct.
@end deffn

@deffn procedure rexp-word-char
Returns a @acronym{REXP} that matches any word-constituent character.
This is equivalent to the @code{\w} construct.
@end deffn

@deffn procedure rexp-not-word-char
Returns a @acronym{REXP} that matches any character that isn't a word
constituent.  This is equivalent to the @code{\W} construct.
@end deffn

The next two procedures accept a @var{syntax-type} argument specifying
the syntax class to be matched against.  This argument is a symbol
selected from the following list.  Each symbol is followed by the
equivalent character used in standard regular-expression notation.
@code{whitespace} (space character),
@code{punctuation} (@code{.}),
@code{word} (@code{w}),
@code{symbol} (@code{_}),
@code{open} (@code{(}),
@code{close} (@code{)}),
@code{quote} (@code{'}),
@code{string-delimiter} (@code{"}),
@code{math-delimiter} (@code{$}),
@code{escape} (@code{\}),
@code{char-quote} (@code{/}),
@code{comment-start} (@code{<}),
@code{comment-end} (@code{>}).

@deffn procedure rexp-syntax-char syntax-type
Returns a @acronym{REXP} that matches any character of type
@var{syntax-type}.  This is equivalent to the @code{\s} construct.
@end deffn

@deffn procedure rexp-not-syntax-char syntax-type
Returns a @acronym{REXP} that matches any character not of type
@var{syntax-type}.  This is equivalent to the @code{\S} construct.
@end deffn

@deffn procedure rexp-sequence rexp @dots{}
Returns a @acronym{REXP} that matches each @var{rexp} argument in
sequence.  If no @var{rexp} argument is supplied, the result matches
the null string.  This is equivalent to concatenating the regular
expressions corresponding to each @var{rexp} argument.
@end deffn

@deffn procedure rexp-alternatives rexp @dots{}
Returns a @acronym{REXP} that matches any of the @var{rexp}
arguments.  This is equivalent to concatenating the regular
expressions corresponding to each @var{rexp} argument, separating them
by the @code{\|} construct.
@end deffn

@deffn procedure rexp-group rexp @dots{}
@code{rexp-group} is like @code{rexp-sequence}, except that the result
is marked as a match group.  This is equivalent to the @code{\(}
@dots{} @code{\)} construct.
@end deffn

The next three procedures in principal accept a single @acronym{REXP}
argument.  For convenience, they accept multiple arguments, which are
converted into a single argument by @code{rexp-group}.  Note, however,
that if only one @acronym{REXP} argument is supplied, and it's very
simple, no grouping occurs.

@deffn procedure rexp* rexp @dots{}
Returns a @acronym{REXP} that matches zero or more instances of the
pattern matched by the @var{rexp} arguments.  This is equivalent to
the @code{*} construct.
@end deffn

@deffn procedure rexp+ rexp @dots{}
Returns a @acronym{REXP} that matches one or more instances of the
pattern matched by the @var{rexp} arguments.  This is equivalent to
the @code{+} construct.
@end deffn

@deffn procedure rexp-optional rexp @dots{}
Returns a @acronym{REXP} that matches zero or one instances of the
pattern matched by the @var{rexp} arguments.  This is equivalent to
the @code{?} construct.
@end deffn

@deffn procedure rexp-case-fold rexp
Returns a @acronym{REXP} that matches the same pattern as @var{rexp},
but is insensitive to character case.  This has no equivalent in
standard regular-expression notation.
@end deffn
